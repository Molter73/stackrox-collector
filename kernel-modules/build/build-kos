#!/usr/bin/env bash

#### LICENSING:
#### This file is derived from sysdig, in scripts/build-probe-binaries.
#### Sysdig is licensed under the GNU General Public License v2.
#### This file is not distributed with StackRox code, and is only
#### used during compilation.
#### This file is heavily modified from the original.

#
# This script builds a precompiled version of sysdig-probe for a bunch of kernels
# The precompiled binary is then obtained at runtime by sysdig-probe-loader
# Ideally, the community should expand this stuff with better support
#
set -euo pipefail

#
# For continuous integration log purposes, wget prints its own output to stderr
# so it can be convenient to redirect it to a file. This can be done directly
# at runtime.
#

BASEDIR=/scratch
ARCH=$(uname -m)
URL_TIMEOUT=300
RETRY=10

DISTRO="$1"

OUTPUT_DIR=/output/$DISTRO/
if [ ! -d $OUTPUT_DIR ]; then
	mkdir -p $OUTPUT_DIR
fi

function build_modules {
	SYSDIG_OUTPUT_KO=$OUTPUT_DIR/collector-$KERNEL_RELEASE.ko

	if [ ! -f $SYSDIG_OUTPUT_KO ]; then

		echo Building modules for $KERNEL_RELEASE [${FUNCNAME[1]}]

		cd /sysdig-src
		export PROBE_NAME=collector
		SYSDIG_KO=driver/$PROBE_NAME.ko
		make -C driver clean || true
		rm -rf ko-build || true
		mkdir ko-build
		cd ko-build
		cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-fno-pie" -DPROBE_NAME=$PROBE_NAME -DBUILD_USERSPACE=OFF ..
		make -j 6 driver
		strip -g $SYSDIG_KO

		KO_VERSION=$(/sbin/modinfo $SYSDIG_KO | grep vermagic | tr -s " " | cut -d " " -f 2)
		if [ "$KO_VERSION" != "$KERNEL_RELEASE" ]; then
			echo "Corrupted probe, KO_VERSION " $KO_VERSION ", KERNEL_RELEASE " $KERNEL_RELEASE
			exit 1
		fi

		cp $SYSDIG_KO $SYSDIG_OUTPUT_KO
	else
		echo Skipping $KERNEL_RELEASE.ko \(already built\)
	fi

	cd $BASEDIR
}

function ubuntu_build {

	URL=$1
	DEB=$(echo $URL | grep -o '[^/]*$')
	KERNEL_RELEASE_FULL=$(echo $DEB | grep -E -o "[0-9]{1}\.[0-9]+\.[0-9]+-[0-9]+\.[0-9]+")		# ex. 3.13.0-24.47
	KERNEL_RELEASE=$(echo $KERNEL_RELEASE_FULL | grep -E -o "[0-9]{1}\.[0-9]+\.[0-9]+-[0-9]+")	# ex. 3.13.0-24
	KERNEL_UPDATE=$(echo $KERNEL_RELEASE_FULL | grep -E -o "[0-9]+$")							# ex. 47

	cd ${BASEDIR}

	if [ ! -d $KERNEL_RELEASE ]; then
		mkdir $KERNEL_RELEASE
	fi

	cd $KERNEL_RELEASE

	if [ ! -d $KERNEL_UPDATE ]; then
		mkdir $KERNEL_UPDATE
	fi

	cd $KERNEL_UPDATE

	if [ ! -f $DEB ]; then
		echo Downloading $DEB [Ubuntu]
		get_or_download $URL ./
		dpkg -x $DEB ./
	fi

	NUM_DEB=$(ls linux-*.deb -1 | wc -l)

	if [ $NUM_DEB -eq 3 ]; then

		local KERNEL_FOLDER=$KERNEL_RELEASE
		KERNEL_RELEASE=$(ls -1 linux-image-* | grep -E -o "[0-9]{1}\.[0-9]+\.[0-9]+-[0-9]+-[a-z]+")

		HASH=$(md5sum boot/config-$KERNEL_RELEASE | cut -d' ' -f1)
		HASH_ORIG=$HASH

		cd $BASEDIR

		export KERNELDIR=$BASEDIR/$KERNEL_FOLDER/$KERNEL_UPDATE/usr/src/linux-headers-$KERNEL_RELEASE
		build_modules
		rm -rf $KERNEL_RELEASE
		# Clean up unpacked packages:
		rm -rf $BASEDIR/$KERNEL_FOLDER/$KERNEL_UPDATE
		echo
	fi

	cd $BASEDIR
}

function rhel_build {

	#
	# The function just requires the rpm url
	#

	# Get all the parameters needed
	URL=$1
	RPM=$(echo $URL | grep -o '[^/]*$')
	KERNEL_RELEASE=$(echo $RPM | awk 'match($0, /[^kernel(\-lt|\-ml)?\-(core\-|devel\-)?].*[^(\.rpm)]/){ print substr($0, RSTART, RLENGTH) }')

	cd ${BASEDIR}

	if [ ! -d $KERNEL_RELEASE ]; then
		mkdir $KERNEL_RELEASE
	fi

	cd $KERNEL_RELEASE

	if [ ! -f $RPM ]; then
		echo Downloading $RPM [RHEL and CentOS]
		get_or_download $URL ./
		rpm2cpio $RPM | cpio -idm
	fi

	NUM_RPM=$(ls kernel-*.rpm -1 | wc -l)

	if [ $NUM_RPM -eq 2 ]; then

		#echo Building $KERNEL_RELEASE

		if [ -f boot/config-$KERNEL_RELEASE ]; then
			HASH=$(md5sum boot/config-$KERNEL_RELEASE | cut -d' ' -f1)
		else
			HASH=$(md5sum lib/modules/$KERNEL_RELEASE/config | cut -d' ' -f1)
		fi

		HASH_ORIG=$HASH

		cd $BASEDIR

		export KERNELDIR=$BASEDIR/$KERNEL_RELEASE/usr/src/kernels/$KERNEL_RELEASE
		build_modules
		# Clean up unpacked packages:
		rm -rf $BASEDIR/$KERNEL_RELEASE
		echo
	fi

	cd $BASEDIR
}

function debian_build {

	URL="${1}"
	DEB="$(echo ${URL} | grep -o '[^/]*$')"
	echo "$URL -> $DEB"

	cd ${BASEDIR}

	if [[ "${DEB}" == *"kbuild"* ]]; then
		if [[ ! -d ${BASEDIR}/common-dependencies/debian/kbuild/ ]]; then
			mkdir -p ${BASEDIR}/common-dependencies/debian/kbuild
		fi
		if [ ! -f ${BASEDIR}/common-dependencies/debian/kbuild/${DEB} ]; then
			echo "Downloading ${DEB} [Debian]"
			get_or_download ${URL} ${BASEDIR}/common-dependencies/debian/kbuild/
		fi
		return
	else
		KERNEL_RELEASE=$(echo ${DEB} | grep -E -o "[0-9]{1}\.[0-9]+\.[0-9]+(-[0-9]+)?"| head -1)
		KERNEL_MAJOR=$(echo ${KERNEL_RELEASE} | grep -E -o "[0-9]{1}\.[0-9]+")
		PACKAGE=$(echo ${DEB} | grep -E -o "(common_[0-9]{1}\.[0-9]+.*amd64|amd64_[0-9]{1}\.[0-9]+.*amd64)" | sed -E 's/(common_|amd64_|_amd64)//g')

		if [[ ! -d ${KERNEL_RELEASE} ]]; then
			mkdir ${KERNEL_RELEASE}
		fi

		cd ${KERNEL_RELEASE}

		if [ ! -d ${PACKAGE} ]; then
			mkdir ${PACKAGE}
		fi

		cd ${PACKAGE}

		if [ ! -f "${DEB}" ]; then
			echo "Downloading ${DEB} [Debian]"
			get_or_download ${URL} ./
			dpkg -x "${DEB}" ./
		fi
	fi

	NUM_DEB=$(ls linux-*.deb -1| grep -v kbuild | wc -l)

	if [[ ${NUM_DEB} -eq 3 ]]; then
		set +e
			KBUILD_PACKAGE=$(ls -t ${BASEDIR}/common-dependencies/debian/kbuild | grep  "kbuild\-${KERNEL_MAJOR}" | head -1)
		set -e
		if [[ ! -z ${KBUILD_PACKAGE} ]]; then
			cp ${BASEDIR}/common-dependencies/debian/kbuild/${KBUILD_PACKAGE} .
			dpkg -x ${KBUILD_PACKAGE} ./

			local KERNEL_FOLDER=${KERNEL_RELEASE}
			KERNEL_RELEASE=$(ls boot/config-* | sed 's|boot/config-||')

			HASH=$(md5sum boot/config-${KERNEL_RELEASE} | cut -d' ' -f1)
			HASH_ORIG=${HASH}

			export KERNELDIR=${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/linux-headers-${KERNEL_RELEASE}

			#fix symbolic links
			unlink ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/lib/modules/${KERNEL_RELEASE}/build
			ln -s ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/linux-headers-${KERNEL_RELEASE} ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/lib/modules/${KERNEL_RELEASE}/build

			common_folder=$(ls ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/ | egrep '*common')
			unlink ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/lib/modules/${KERNEL_RELEASE}/source
			ln -s ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/${common_folder}  ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/lib/modules/${KERNEL_RELEASE}/source

			#hack Makefile
			sed -i '0,/MAKEARGS.*$/s||MAKEARGS := -C '"${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/${common_folder}"' O='"${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/linux-headers-${KERNEL_RELEASE}"'|' ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/linux-headers-${KERNEL_RELEASE}/Makefile
			sed -i 's/@://' ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/linux-headers-${KERNEL_RELEASE}/Makefile
			sed -i 's|$(cmd) %.*$|$(cmd) : all|' ${BASEDIR}/${KERNEL_FOLDER}/${PACKAGE}/usr/src/linux-headers-${KERNEL_RELEASE}/Makefile

			cd ${BASEDIR}

			build_modules

			# Clean up unpacked packages:
			rm -rf ${BASEDIR}/${KERNEL_FOLDER}
			echo
		fi
	fi

	cd ${BASEDIR}
}

function coreos_build {
	BASE_URL="$1"

	get_or_download ${BASE_URL}version.txt ./
	eval $(cat ./version.txt)

	COREOS_DIR="coreos-$COREOS_VERSION_ID"

	if [ ! -d $COREOS_DIR ]; then
		mkdir $COREOS_DIR
	fi

	cd $COREOS_DIR

	if [ ! -f coreos_developer_container.bin ]; then
		get_or_download ${BASE_URL}coreos_developer_container.bin.bz2 ./
		echo "Unzipping developer container"
		bunzip2 coreos_developer_container.bin.bz2
	fi

	if [ ! -f config_orig ]; then
		echo "Obtaining config_orig"
		# mount developer container is a very stateful part of this script
		# the section between mount/unmounting should be kept very small
		# otherwise if something fails there are many inconsistencies that can happen
		kpartx -asv coreos_developer_container.bin
		LOOPDEV=$(kpartx -asv coreos_developer_container.bin | cut -d\  -f 3)
		mkdir -p /tmp/loop
		mount /dev/mapper/$LOOPDEV /tmp/loop

		# Copy kernel headers
		cp -r /tmp/loop/lib/modules .

		# Copy kernel config
		rm config* || true
		cp /tmp/loop/usr/boot/config-* .
		cp config-* config_orig
		cp config_orig config

		# umount and remove the developer container
		umount /tmp/loop
		kpartx -dv coreos_developer_container.bin
	fi

	echo "Building"
	# https://groups.google.com/forum/#!topic/coreos-dev/Z8Q7sIy6YwE
	sed -i 's/CONFIG_INITRAMFS_SOURCE=""/CONFIG_INITRAMFS_SOURCE="bootengine.cpio"\nCONFIG_INITRAMFS_ROOT_UID=0\nCONFIG_INITRAMFS_ROOT_GID=0/' config
	sed -i 'N;s/\(CONFIG_RD_LZ4=.\)\n\(CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=\)/\1\nCONFIG_INITRAMFS_COMPRESSION=".gz"\n\2/' config
	KERNEL_RELEASE=$(ls config-* | sed s/config-//)
	HASH_ORIG=$(md5sum config_orig | cut -d' ' -f1)
	HASH=$(md5sum config | cut -d' ' -f1)

	export KERNELDIR=$PWD/modules/$KERNEL_RELEASE/build
	build_modules
	cd $BASEDIR
	# Clean up unpacked packages:
	rm -rf $BASEDIR/$COREOS_DIR

	return
}

function get_or_download() {
	URL="$1"
	DIR="$2"

	CACHE_PATH="/packages/${URL}"
	if [ -f "${CACHE_PATH}" ]; then
		echo "Using cached ${URL}"
	else
		echo "Downloading ${URL}"
		wget --no-verbose --timeout=${URL_TIMEOUT} --tries=${RETRY} -P "$(dirname ${CACHE_PATH})" ${URL}
		echo "Done downloading"
	fi

	cp ${CACHE_PATH} ${DIR}
}

INPUT="${2:-/dev/stdin}"
echo "Reading package URLs from $INPUT"

case "$DISTRO" in
	Ubuntu)
		echo Building Ubuntu

		while read URL
		do
			echo "Processing package $URL"
			ubuntu_build "$(echo $URL | tr -d '\r')"
		done < $INPUT
	;;

	RedHat)
		echo Building RHEL

		while read URL
		do
			echo "Processing package $URL"
			rhel_build "$(echo $URL | tr -d '\r')"
		done < $INPUT
	;;

	Fedora)
		echo Building Fedora

		while read URL
		do
			echo "Processing package $URL"
			rhel_build "$(echo $URL | tr -d '\r')"
		done < $INPUT
	;;

	Debian)
		echo Building Debian

		while read URL
		do
			echo "Processing package $URL"
			debian_build "$(echo $URL | tr -d '\r')"
		done < $INPUT
	;;

	CoreOS)
		echo Building CoreOS

		while read URL
		do
			echo "Processing version $URL"
			coreos_build "$(echo $URL | tr -d '\r')"
		done < $INPUT
	;;

	*)
		echo Unknown distro.
		rm -rf $OUTPUT_DIR || true
		exit 1
	;;
esac

echo 'Done!'
